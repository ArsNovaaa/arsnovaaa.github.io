---
layout: post
title: C++面试
date: 2025-2-23 20:08 +0800
last_modified_at: 2025-2-27 21:08 +0800
tags: [C++, Notes]
toc:  false
---
### 虚函数表和虚函数表指针的创建

虚函数表实际是一个虚函数地址的数组，其指向为具体的代码区的位置。
- 背景：用来实现多态机制
- 生成：编译器编译的时候生成，由virtual关键字修饰。
- 存放位置：可执行程序状态下，存放在磁盘；运行状态，存放在内存中。
- 虚拟内存分区：栈区（栈区之上时内核空间）、文件映射区、堆区、数据区（静态存储区）和代码区。
可执行程序中不同部分存储的内容如下：
<table>
  <thead>
    <tr>
      <th>可执行程序中（磁盘）</th>
      <th>作用</th>
      <th>对应虚拟内存分区（内存）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>.bss</td>
      <td>未初始化的或初始化为0的全局、静态变量</td>
      <td>静态存储区</td>
    </tr>
    <tr>
      <td>.data</td>
      <td>初始化的全局、静态变量</td>
      <td>静态存储区</td>
    </tr>
    <tr>
      <td>.rodata</td>
      <td>只读数据段和虚函数表</td>
      <td>代码区</td>
    </tr>
        <tr>
      <td>.text</td>
      <td>具体代码表</td>
      <td>代码区</td>
    </tr>
  </tbody>
</table>

- <mark>虚函数表指针的创建时机：</mark>

1. <mark>类对象构造的时候，把类的虚函数表地址赋值给vptr。</mark>
2. 没有构造函数，编译器会生成默认的构造函数（有第一条的作用）。
3. 继承的情况下（例如B继承A），先调用基类的构造函数，把A的虚函数表的地址赋值给vptr。再调用子类构造函数，把B的虚函数表的地址赋值给vptr。

### 虚函数表和虚函数表指针的关系
<mark>每个类只有一个虚函数表，类的不同对象通常来说虚函数表指针vptr(每个类实例有一个)是不一样的</mark>（自身地址不一样，指向的内容一样，为深拷贝。浅拷贝会导致一个置null后另一个类实例找不到虚函数表）。使用的时候需要显式地定义拷贝构造函数或重载赋值运算符。

